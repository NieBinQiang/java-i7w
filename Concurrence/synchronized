# 临界区
- 临界区是指**一个访问共用资源的程序片段，而这些共用资源又无法同时被多个线程访问。**
- 在java中，当一个线程试图访问一个临界区时，他将使用一种同步机制来查看是不是已经有其他线程进入临界区。如果没有，则他就可以进入临界区；否则他就会被同步机制挂起，直到进入的线程离开这个临界区。
# synchronized
## 简介
- synchronized，即锁，主要用来**给方法、代码块加锁**。
- 当某个方法或者代码块使用synchronized时，那么在**同一时刻至多仅有有一个线程在执行该段代码**。
- 当有多个线程访问同一对象的加锁方法/代码块时**，同一时间只有一个线程在执行**，其余线程必须要等待当前线程执行完之后才能执行该代码段。
- 但是，**其余线程是可以访问该对象中的非加锁代码块的。**
- **退出或抛出异常时必须释放锁**

## synchronized 方法
通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：

```java
public synchronized void getResult();
```
使用了synchronized关键字表明该方法已加锁，在任一线程在访问改方法时都必须要**判断该方法是否有其他线程在“独占”**。**每个类实例对应一个把锁**，每个synchronized方法都必须调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，被阻塞的线程方能获得该锁。

synchronized方法的缺陷，调用时会把整个方法锁住，其他线程只能挂起等待，大大影响效率。

## synchronized 块
- synchronized代码块作用与synchronized方法功能一样，但它提供更灵活、更短的临界区。
- 使用同步代码块时候，必须通过一个对象引用来作为参数，该参数常用this。

```java
synchronized (this) {
    //允许访问控制的代码 
}
```
synchronized(this)的理解：
- 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
- 当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有**其他synchronized(this)同步代码块得访问将被阻塞**。
- 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然**可以访问object中的非synchronized(this)同步代码块**。
- 当一个线程访问object的一个synchronized(this)同步代码块时，它就**获得了这个object的对象锁**。结果，其他线程对该object对象所有同步代码部分的访问都将被暂时阻塞。

# synchronized进阶
## 锁是什么？
- 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象。  
- 对于同步方法，锁是**当前实例对象**。对于同步方法块，锁是Synchonized**括号里配置的对象（通常配置为this，即当前实例对象）**。对于静态同步方法，锁是当前对象的**Class对象**。
- **如果要对这些线程进行同步，那么这些线程所持有的对象锁应当是共享且唯一的。**
- 如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized的instance函数B，那么这个类的同一对象Obj,在多线程中分别访问A和B两个方法时，**不会构成同步**，因为它们的**锁都不一样**。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。

## 锁升级
java中锁一共有四种状态，**无锁状态**，**偏向锁状态**，**轻量级锁状态**和**重量级锁状态**，它会**随着竞争情况逐渐升级**。锁可以升级但**不能降级**。

### 锁自旋
我们知道在当某个线程在进入同步方法/代码块时若发现该同步方法/代码块被其他现在所占，则它就要等待，进入阻塞状态，这个过程性能是低下的。

在遇到锁的争用或许等待事，线程可以**不那么着急进入阻塞状态，而是等一等，看看锁是不是马上就释放了**，这就是**锁自旋**。锁自旋在一定程度上可以对线程进行优化处理。

### 偏向锁
- 偏向锁主要为了解决在**没有竞争情况**下锁的性能问题。
- 当某个线程获得锁的情况，该线程是可以多次锁住该对象，但是每次执行这样的操作都会因为CAS（CPU的Compare-And-Swap指令）操作而造成一些开销消耗性能，为了减少这种开销，**这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。**
- 当有其他线程在尝试着竞争偏向锁时，**持有偏向锁的线程就会释放锁**。

### 锁膨胀  
多个或多次调用粒度太小的锁，进行加锁解锁的消耗，反而还不如一次大粒度的锁调用来得高效。

### 轻量级锁
轻量级锁能提升程序同步性能的依据是“**对于绝大部分的锁，在整个同步周期内都是不存在竞争的**”，这是一个**经验数据**。轻量级锁在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的指向和状态。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

### 重量级锁 即Synchonized

# 其他
参考[http://ifeve.com/java-synchronized/](http://ifeve.com/java-synchronized/)
## CAS 
CAS（Compare and Swap）比较并设置。用于在**硬件层面上提供原子性操作**。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，**如果一致则修改，不一致则不修改**。

## synchronized 同步原理
JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。

- 代码块同步是使用**monitorenter**和**monitorexit**指令实现，
- 而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。**monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处**，JVM要**保证每个monitorenter必须有对应的monitorexit与之配对**。
- 任何对象都有一个 monitor 与之关联，**当且一个monitor 被持有后，它将处于锁定状态**。**线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。**
