## 一、对`java`平台的理解
- `java`是门面向面向对象语言(封装、继承、多态)，最显著的特性有两个方面:
- - **平台无关性**。“一次编写，导出执行”--强大的跨平台能力，基于强大的`java`虚拟机。`java`源代码经过编译成为能在`java`虚拟机运行的`.class`字节码，然后java虚拟机在运行时，把字节码解释成机器码运行。
- - **垃圾回收机制**。`java`虚拟机提供垃圾回收机制，通过jvm提供的垃圾收集器回收和分配内存。
- `java`语言特性：泛型、反射等
- `java`丰富的类库：核心类库、集合、`IO/NIO`、网络、并发、安全等
- `JRE（Java Runtime Environment）`，是指`Java`运行环境,包含了`JVM`和`Java`类库
- `jdk`，`JRE`的一个超集，提供各种强大的工具，包括`JRE`，`javac`(`java`语言编程编译器)，诊断工具等

## 二、对“java是解释执行”的理解 
- 不太准确
- 一般情况，开发的源代码，首先通过`javac`编译成字节码，然后，在运行时，通过java虚拟机（JVM）内嵌的解析器将字节码转换成最终的机械码。
- 但是常见的 `JVM`，比如我们大多数情况使用的 `OracleJDK` 提供的 **`Hotspot JVM`**，都提供了 **`JIT（Just-In-Time）`编译器**，也就是通常所说的**动态编译器**，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于**编译执行**，而不是解释执行了。

## PS：知识拓展
1. `java`泛型、`java`反射
2. `java`集合包、`java`并发包
3. `java`三个`ClassLoader`及`java`类加载机制
4. `java`垃圾回收机制
5. `java`常见垃圾收集器（`SerialGC`、`Parallel GC`、 `CMS`、 `G1`）
及其原理、各自适用于什么工作负载
6. `jdk`常见工具类（`jdk` 9 `AOT` 特性）

## 三、对比 `Exception` 和 `Error`
![image](https://github.com/NieBinQiang/java-i7w/blob/master/pic/Throwable.png)
- `Exception`类和`Error`都继承于`Throwable`，只有继承`Throwable`才可以被抛出或捕获
，他们是异常处理机制的基本组成类型
- `Exception`是在程序运行中，可以预料的，并且应该被捕获进行处理的异常；`Error`则是不大可能出现的错误，会导致程序处于非正常、不可恢复状态。

## 四、运行时异常和一般异常有什么区别
- `Exception`分为两种：可检查异常（`checkedException`）和不可检测异常（也叫做运行时异常 `RuntimeException`）
- 可检查异常：在源代码必须进行捕获，是编译检查的一部分
- 不可检查异常：即运行时异常，如`NullPointerException`、`ArrayOutOfBoundsException`等，这些通常是可以编码避免的逻辑错误，具体根据需要来判断是否捕获，并不会在编译时强制要求。

## PS：知识拓展
1. 异常处理的最佳实践
2. `NoClassDefFound`和`ClassNotFoundExcepTion`区别
3. 异常机制的性能开销

# 五、谈谈final、finally、finalize有什么不同？
- `final`用于修饰**类、方法、变量**。
- - `final`修饰class代表该类**不可以被继承**
- - `final`修饰方法表示该方法**不可以被override**
- - `final`修饰变量表示该变量**不可以被修改**
- `finally`是`java`**保证重点代码一定要被执行**的一种机制。比如我们可以使用`try-catch-finally`来**关闭JDBC连接**、**保证unlock锁**等操作
- `finalize`是基础类`java.lang.Object`的一个方法，它的设计目的是**保证对象在被垃圾收集前完成特定资源的回收**。`finalize`机制现在已经**不推荐使用**，`jdk` 9 开始被标记为`deprecate`。

## PS:：知识拓展
1. `final`相关最佳实践
2. `try-with-resource`机制
3. `final`、`finally`相关实践细节

## 六、强引用、软引用、弱引用、幻想引用的区别，具体使用场合？
- 强引用，即我们**常见的普通对象引用**。只要**还有强引用指向一个对象，就表明对象还“活着”**，垃圾收集器不会去碰这类对象。一个普通对象，如果没有其他引用关系，只要**超过引用的作用域**或者**显式地将相应的强引用赋值null**，就可以被垃圾收集器收集（具体回收时机还需看具体垃圾收集策略）。
- 软引用，相对强引用弱化一些的引用，**可以让对象避免一些垃圾收集**。**只有当JVM认为内存不足，才会试图回收软引用所指向的对象**。Jvm会确保抛出OutOfMemoryError之前，先清理软引用指定对象。软引用通常用来**实现内存敏感的缓存**，如果还有空闲的内存，就暂时保留缓存，当内存不足时清理掉。这样保证使用缓存时不会耗尽内存。
- 弱引用，它并**不能使对象避免垃圾收集**，只是**提供访问在弱引用状态下对象的途径**。同样是很多**缓存实现的选择**
- 幻象引用，也作**虚引用**，它仅是提供一种确保对象被`finalize`以后，做某事情的机制。如** `Post-Mortem` 清理机制**。

## 七、String、StringBuffer、StringBuilder的区别
- `String`是java语言的**基础类**，提供构造和管理字符串的各种基本逻辑。它是典型的**`Immutable`类**，被声明成`final` `class`，所有属性都是`final`的。因为不可变性，如**拼接、裁剪字符串等动作都会产生新的`String`对象**。
- `StringBuffer` 是为了解决上面提到的拼接、裁剪产生太多中间对象的问题而提供的一个类。`String`本质是一个**线程安全**的**可修改字符串序列**，他保证了线程安全，也随之带来额外的性能开销。所以除非有线程安全考虑，**一般推荐使用`StringBuilder`**
- `StringBuilder`，能力上和`StringBuffer`没有本质区别，但**去掉了线程安全部分**，有效减小了开销，是字符串拼接的首选。

